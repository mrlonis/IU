 Here are the solutions to the early evaluation exam. Discussion follows. 

1. False. 

A method may have zero, one or more return statements. 

Maybe we should give some examples here: 

class One {
  public static void main(String[] args) { // this method, main, has zero return statements
    for (int i = 0; i < 10; i++) {
      System.out.println( One.randomValue( 100, 30 ); // prints random int in [30, 130)
    }   
    System.out.println( One.contains("aeiouAEIOU", "watermelon".substring( 2, 3)) ); // checks if 3rd letter in "watermelon" is a vowel or not
  }
  public static void randomValue(int range, int offset) { // this method has one return statement 
    return Math.random( (int) (Math.random() * range + offset) ); // the returned value is one of many (range)
  } 
  public static boolean contains(String one, String letter) { // this method has two return statements 
    for (int i = 0; i < one.length(); i++) 
      if (one.substring(i, i+1).equals( letter )) {
        return true; 
      }
    } 
    return false; 
  }   
}

2. False, see above. 

3. False.

On page 203 of your textbook the term "return value" is defined. 

It doesn't mean "return type". A method has only one return type. 

But as is shown in the answer to the first question a method can return two or more values. 

In fact the simplest justification to this question is: no return type has cardinality one. 

void has cardinality zero, boolean has cardinality two and everything else is by and large infinite. 

4. False. 

A return is not necessary if the return type is void, but if it occurs (with no argument) it ends the method. 

If used that way it reminds the use of break in loops, only in a more generalized way, at the method level. 

Maybe I should give an example from your book: take a look at page 215. 

What does this method do: 

public static void mystery(int size) {
  if (size <= 6) {
    return; // too small, won't draw it.
  } 
  for (int i = 0; i < size; i++) {
    for (int j = 0; j < size; j++) { 
      if (i == j || j == 0 || j == size-1) 
        System.out.print("* "); 
      else 
        System.out.print("  "); 
    }  
    System.out.println(); 
  }
}

Here's a test:

-bash-4.1$ cat Five.java
class Five {
  public static void main(String[] args) {
    Five.mystery(Integer.parseInt(args[0]));
  }
  public static void mystery(int size) {
    if (size <= 6) {
      return; // too small, won't draw it.
    }
    for (int i = 0; i < size; i++) {
      for (int j = 0; j < size; j++) {
        if (i == j || j == 0 || j == size-1)
          System.out.print("* ");
        else
          System.out.print("  ");
      }
      System.out.println();
    }
  }
}
-bash-4.1$ javac Five.java
-bash-4.1$ java Five 7
*           *
* *         *
*   *       *
*     *     *
*       *   *
*         * *
*           *
-bash-4.1$ java Five 15
*                           *
* *                         *
*   *                       *
*     *                     *
*       *                   *
*         *                 *
*           *               *
*             *             *
*               *           *
*                 *         *
*                   *       *
*                     *     *
*                       *   *
*                         * *
*                           *
-bash-4.1$ java Five 6
-bash-4.1$ java Five -23
-bash-4.1$

So hopefully this settles it. 

5. True. See the example above. 

6. False. See Math.random()

7-10.

-bash-4.1$ cat Seven.java
class Seven {

  public static double f(double x) { return g(x) + Math.sqrt(h(x)); }
  public static double g(double x) { return 4 * h(x); }
  public static double h(double x) { return x * x + k(x) - 1; }
  public static double k(double x) { return 2 * (x + 1); }

  public static void main(String[] args) {
    double x1 = f(2);
    System.out.println( x1 );
    double x2 = g(h(2));
    System.out.println( x2 );
    double x3 = k(g(2) + h(2));
    System.out.println( x3 );
    double x4 = f(0) + f(1) + f(2);
    System.out.println( x4 );
  }
}
-bash-4.1$ javac Seven.java
-bash-4.1$ java Seven
39.0
400.0
92.0
62.0
-bash-4.1$

11-13. Let's try that: 

-bash-4.1$ cat Eleven.java
class Eleven {
  public static void main(String[] args) {
    System.out.println("--------------------(11)------");
    for (int i = 1; i < 10; i++) { System.out.print(i + " "); }
    System.out.println("--------------------(12)------");
    for (int i = 1; i < 10; i+=2) { System.out.print(i + " "); }
    System.out.println("--------------------(13)------");
    for (int i = 10; i > 1; i--) { System.out.print(i + " "); }
  }
}
-bash-4.1$ javac Eleven.java
-bash-4.1$ java Eleven
--------------------(11)------
1 2 3 4 5 6 7 8 9 --------------------(12)------
1 3 5 7 9 --------------------(13)------
10 9 8 7 6 5 4 3 2 -bash-4.1$


The correct answers then were: 

  11. The integers from [1, 10) 

  12. The odd integers in [1, 10) 
  
  13. The integers in (1, 10] in reverse order. 

14. int sum = 0; 
    for (int i = 2; i <= 100; i++) {
      if (i % 2 == 0) 
        sum += i; 
    } 
    System.out.println( sum ); 

This is the more general form. 

The more specific version could use i+=2 to step only on even numbers without checking. 

15. int sum = 0; 
    for (int i = a; i <= b; i++) {
      if (i % 2 == 1) 
        sum += i; 
    } 

16. See Homework Three. 

From the book see for example around pages 172-173

  https://www.cs.indiana.edu/classes/c212-dgerman/spr2013/classNotes/four/image018.jpg



17. 10 iterations 

18. 11 iterations 

19. 10 iterations 

20. 21 iterations 

21. 11 iterations for i == -10, -8, -6, -4, -2, 0, 2, 4, 6, 8 and 10

Here is how you can measure this: 

-bash-4.1$ cat Seventeen.java
class Seventeen {
  public static void main(String[] args) {

    int count = 0;
    for (int i = 1; i <= 10; i++) { count += 1; }
    System.out.println( "17. " + count + " iterations. ");

    count = 0;
    for (int i = 0; i <= 10; i++) { count += 1; }
    System.out.println( "18. " + count + " iterations. ");

    count = 0;
    for (int i = 10; i > 0; i--) { count += 1; }
    System.out.println( "19. " + count + " iterations. ");

    count = 0;
    for (int i = -10; i <= 10; i++) { count += 1; }
    System.out.println( "20. " + count + " iterations. ");

    count = 0;
    for (int i = -10; i <= 10; i = i + 2) { count += 1; }
    System.out.println( "21. " + count + " iterations. ");

  }
}
-bash-4.1$ javac Seventeen.java
-bash-4.1$ java Seventeen
17. 10 iterations.
18. 11 iterations.
19. 10 iterations.
20. 21 iterations.
21. 11 iterations.
-bash-4.1$


22. In the code on the left s counts the number of positive values in x and y (0, 1 or 2). 

On the right a positive y is only counted if x is positive otherwise not. 

So for x = 2 and y = 1 the value of s on the left is 2 but on the right it is 1 (as y is not counted any more). 

The reason the problem looks hard: 

   (a) the fragments are equivalent if both x < 0 and y < 0
   (b) the fragments are equivalent if either x < 0 or y < 0

The only time when they are not agreeing with each other is when x >= 0 and y >= 0. 

23. y = ( x > 0 ) ? x : 0; 

Or: 

   y = 0; 
   if (x > 0) { 
     y = x; 
   } 

Or: 

   if (x > 0) {
     y = x; 
   } else {
     y = 0; 
   } 

24. false && true == false 

25. false || false == false 

26. true && true == true 

27. true || false == true 

28. b

29. ! b

30. ! b (same as 29) 

31. b (same as 28)

32. b = ( n == 0 ); 

33. b = ( n != 0 ); 

34. b = (1 < n && n < 2); 

which can be further simplified to 

    b = false; 

(assuming that n is an int). 

35. b = ( n < 1 ) || ( n > 2 ); 

This can be simplified to 

    b != 1 and b != 2

(assuming that n is an int). 

36. Here's how I code correctly in my obsessive-compulsive way (all curly braces, all branches): 

    if (gpa >= 1.5) {
      if (gpa < 2) {
        System.out.println("Probation."); 
      } else { 

      } 
    } else { 
      System.out.println("Failing."); 
    } 

The rules are: else is optional and blocks of one statement don't need curly braces. 

If I apply this blindly I get: 

    if (gpa >= 1.5) 
      if (gpa < 2) 
        System.out.println("Probation."); 
    else  
      System.out.println("Failing."); 
     
But this is wrong, because it runs like this: 

    if (gpa >= 1.5) 
      if (gpa < 2) 
        System.out.println("Probation."); 
      else  
        System.out.println("Failing."); 

We discussed this in class and notes. So the "moving" else they say "dangles" without the curly braces around the inner if. 

37-41. 

-bash-4.1$ pico -w Forty.java
-bash-4.1$ cat Forty.java
class Forty {
  public static void main(String[] args) {
    int n = 17, m = 18;

    System.out.println( "37. " + (n / 10 + n % 10) );
    System.out.println( "38. " + (n % 2 + m % 2) );
    System.out.println( "39. " + (m + n) / 2 );
    System.out.println( "40. " + (m + n) / 2.0 );
    System.out.println( "41. " + (int) (0.5 * (m + n)) );

  }
}
-bash-4.1$ javac Forty.java
-bash-4.1$ java Forty
37. 8
38. 1
39. 17
40. 17.5
41. 17
-bash-4.1$

42-46. 

-bash-4.1$ pico -w Fifty.java
-bash-4.1$ cat Fifty.java
class Fifty {
  public static void main(String[] args) {

    String s = "Hello", t = "World";

    System.out.println( "42. " + (s.length() + t.length()                ) );
    System.out.println( "43. " + (s.substring(1, 2)                      ) );
    System.out.println( "44. " + (s.substring(s.length() / 2, s.length())) );
    System.out.println( "45. " + (s + t                                  ) );
    System.out.println( "46. " + (t.substring(0, 1) + s.substring(1, 4)  ) );

  }
}
-bash-4.1$ javac Fifty.java
-bash-4.1$ java Fifty
42. 10
43. e
44. llo
45. HelloWorld
46. Well
-bash-4.1$

47. System.out.println("\\n\""); is the part that's interesting. 

48. 4 6 8 (as discussed in class during the mock exam) 

49. (int) (Math.random() * 101)

50. The first is a number the second is a String. Try printing them. 

51. false 

52. The loop starts and has an empty body, i stays 10 forever, and the program never ends. 

-- 
